iner(node, container, slotted);
    this._forceUpdateChildren(container);

    this.inspector.emit("container-created", container);

    return container;
  },

  _onResourceAvailable: async function(resources) {
    for (const resource of resources) {
      if (resource.resourceType !== this.resourceWatcher.TYPES.ROOT_NODE) {
        // Only handle root-node resources
        continue;
      }

      if (resource.targetFront.isTopLevel && resource.isTopLevelDocument) {
        // The topmost root node will lead to the destruction and recreation of
        // the MarkupView. This is handled by the inspector.
        continue;
      }

      const parentNodeFront = resource.parentNode();
      const container = this.getContainer(parentNodeFront);
      if (container) {
        // If there is no container for the parentNodeFront, the markup view is
        // currently not watching this part of the tree.
        this._forceUpdateChildren(container, {
          flash: true,
          updateLevel: true,
        });
      }
    }
  },

  /**
   * Mutation observer used for included nodes.
   */
  _onWalkerMutations: function(mutations) {
    for (const mutation of mutations) {
      const type = mutation.type;
      const target = mutation.target;

      const container = this.getContainer(target);
      if (!container) {
        // Container might not exist if this came from a load event for a node
        // we're not viewing.
        continue;
      }

      if (
        type === "attributes" ||
        type === "characterData" ||
        type === "customElementDefined" ||
        type === "events" ||
        type === "pseudoClassLock" ||
        type === "mutationBreakpoint"
      ) {
        container.update();
      } else if (
        type === "childList" ||
        type === "nativeAnonymousChildList" ||
        type === "slotchange" ||
        type === "shadowRootAttached"
      ) {
        this._forceUpdateChildren(container, {
          flash: true,
          updateLevel: true,
        });
      } else if (type === "inlineTextChild") {
        this._forceUpdateChildren(container, { flash: true });
        container.update();
      }
    }

    this._waitForChildren().then(() => {
      if (this._destroyed) {
        // Could not fully update after markup mutations, the markup-view was destroyed
        // while waiting for children. Bail out silently.
        return;
      }
      this._flashMutatedNodes(mutations);
      this.inspector.emit("markupmutation", mutations);

      // Since the htmlEditor is absolutely positioned, a mutation may change
      // the location in which it should be shown.
      if (this.htmlEditor) {
        this.htmlEditor.refresh();
      }
    });
  },

 